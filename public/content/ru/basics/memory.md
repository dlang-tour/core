# Память

D является системным языком программирования и, таким образом, позволяет вручную
управлять памятью или даже испортить её. Тем не менее, по умолчанию D использует
*сборщик мусора* для освобождения неиспользуемой памяти.

D предоставляет тип указателя `T*`, подобно языку C:

    int a;
    int* b = &a; // b содержит адрес переменной a
    auto c = &a // c является int* и содержит
                // адрес переменной a

Новый блок памяти в куче выделяется с помощью выражения `new`, которое
возвращает указатель на управляемую память:

    int* a = new int;

Как только на память, на которую ссылается `a`, не будет больше ссылаться ни
одна переменная в программе, сборщик мусора освободит её.

D также разрешает арифметику указателей, за исключением кода, помеченного
как @safe.

    void main() @safe {
        int a = 5;
        int* p = &a;
        int* c = p + 5; // ошибка
    }

Если не указано иное значение, то по умолчанию используется `@system`.
Использование `@safe`, подмножества языка D, может быть использовано
принудительно, чтобы намеренно предотвратить любые ошибки, связанные с памятью.
Код, отмеченный как `@safe`, может вызывать только другие `@safe` или `@trusted`
функции. Функции `@trusted` - это вручную проверенные функции, позволяющие
связать мир SafeD и основополагающий грязный низкоуровневый мир.

### Подробнее

* [SafeD](https://dlang.org/safed.html)

## {SourceCode}

```d
import std.stdio;

void safeFun() @safe
{
    writeln("Hello World");
    // выделение памяти со сборщиком мусора
    // также является безопасным
    int* p = new int;
}

void unsafeFun()
{
    int* p = new int;
    int* fiddling = p + 5;
}

void main()
{
    safeFun();
    unsafeFun();
}
```

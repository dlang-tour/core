# Массивы

В D есть два типа массивов: **статические** и **динамические**.
При доступе к любому типу массива всегда проверяется выход за его границы и
при выходе произойдёт прерывание выполнения приложения с сообщением об ошибке
`RangeError`. Смельчаки могут запретить такие проверки с помощью флага
компилятора `-boundschecks=off`, чтобы выжать побольше производительности их
своих двоичных файлов.

#### Статические массивы

Статические массивы хранятся на стеке, если определены внутри функции, либо в
статической памяти в других случаях. Они имеют фиксированную длину, известную
ещё на этапе компиляции. Тип статического массива содержит фиксированный размер:

    int[8] arr;

Тип `arr` - `int[8]`. Обратите внимание, что размер массива указан рядом с
типом, а не после имени переменной, как в C/C++.

#### Динамические массивы

Динамические массивы хранятся в куче и могут увеличиваться или уменьшаться во
время выполнения программы. Динамический массив создаётся используя оператор
`new` и указания размера:

    int size = 8; // run-time переменная
    int[] arr = new int[size];

Тип `arr` - `int[]`, который является **срезом** (slice) и будет рассмотрен
более подробно в следующем разделе. Многомерные массивы могут быть легко созданы
используя синтаксис `auto arr = new int[3][3]`.

#### Операции с массивами и свойства

Массивы могут быть объединены с помощью оператора `~`, который создаст новый
динамический массив.

Математические операции могут быть применены ко всему массиву с использованием
синтаксиса `c[] = a[] + b[]`, который, например, прибавит все элементы `a` и
`b`, то есть получится `c[0] = a[0] + b[0]`, `c[1] = a[1] + b[1]` и т.д. Также
возможно выполнять операции со всем массивом, используя только одно значение:

    a[] *= 2;  // умножить все элементы на 2
    a[] %= 26; // вычисление по модулю 26
               // для всего массива `a`

Такие операции могут быть оптимизированы компилятором, чтобы были использованы
специальные инструкции процессоров, которые выполняют операции в один приём.

Оба типа массивов содержать свойство `.length`, которое можно только читать в
случае статических массивов и которое можно также записывать в случае
динамических массивов, чтобы динамически изменять их размер. Свойство `.dup`
создаёт копию массива.

При индексации массива с помощью синтаксиса `arr[idx]`, специальный синтаксис
`$` означает длину массива. Например, `arr[$ - 1]` ссылается на последний
элемент и является короткой формой записи `arr[arr.length - 1]`.

### Упражнение

Завершите функцию `encrypt` для того, чтобы расшифровать секретное сообщение.
Текст должен быть зашифрован с помощью *Шифра Цезаря*, который сдвигает символы
в алфавите, используя определённый индекс. Шифруемый текст просто содержит
символы из диапазона `a-z`, что должно облегчить задачу.

### Подробнее

- [Массивы в _Programming in D_](http://ddili.org/ders/d.en/arrays.html)
- [Спецификация массивов](https://dlang.org/spec/arrays.html)

## {SourceCode:incomplete}

```d
import std.stdio;

/**
Сдвигает каждый символ в массиве
`input` для символов `shift`.
Диапазон символов ограничен `a-z`
и следующим символом после `z` идёт `a`.

Параметры:
    input = массив для сдвига
    shift = длина сдвига для каждого символа
Возвращается:
    Массив сдвинутых символов
*/
char[] encrypt(char[] input, char shift)
{
    auto result = input.dup;
    // ...
    return result;
}

void main()
{
    // Теперь мы зашифруем сообщение
    // шифром Цезаря и величиной сдвига 16!
    char[] toBeEncrypted = [ 'w','e','l','c',
      'o','m','e','t','o','d',
      // Последняя запятая будет просто
      // проигнорирована!
    ];
    writeln("Before: ", toBeEncrypted);
    auto encrypted = encrypt(toBeEncrypted, 16);
    writeln("After: ", encrypted);

    // Убедимся, что алгоритм работает так, как
    // ожидается
    assert(encrypted == [ 'm','u','b','s','e',
            'c','u','j','e','t' ]);
}
```

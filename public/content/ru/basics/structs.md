# Структуры

Один из способов определить объединённый или пользовательский тип в D - это
задать его через `struct`:

    struct Person {
        int age;
        int height;
        float ageXHeight;
    }

Структуры всегда создаются на стеке (если не созданы через `new`) и копируются
**по значению** при присвоениях или при передаче в качестве параметра при вызове
функции.

    auto p = Person(30, 180, 3.1415);
    auto t = p; // создаётся копия

При создании нового объекта типа `struct`, его создаваемые члены могут быть
инициализированы в порядке, в котором они определены в структуре.
Пользовательский конструктор можно задать с помощью функции-члена `this(...)`.
При необходимости избежания конфликта имён, текущий экземпляр может быть явно
доступен через `this`:

    struct Person {
        this(int age, int height) {
            this.age = age;
            this.height = height;
            this.ageXHeight = cast(float)age * height;
        }
            ...

    Person p(30, 180); // инициализация
    p = Person(30, 180);  //присвоение нового экземпляра

Структура может содержать любое число функций-членов. Они по умолчанию являются
`public` и доступны снаружи. Также они могут быть `private` и, таким образом,
смогут вызываться только функциями-членами этой же структуры, либо другим кодом
того же модуля.

    struct Person {
        void doStuff() {
            ...
        private void privateStuff() {
            ...

    p.doStuff(); // вызов метода doStuff
    p.privateStuff(); // запрещено

### Const функции-члены

Если функция-член объявлена как `const`, то будет невозможно изменить любой из
её членов. Это обеспечивается компилятором. Создание `const` функции-члена
делает её вызываемой из любого `const` или `immutable` объекта и также
гарантирует этим объектам, что функция-член никогда не изменит состояние
объекта.

### Static функции-члены

Если функция-член объявлена как `static`, она может быть вызвана без создания
экземпляра объекта, вроде `Person.myStatic()`, но не будет доступа к любым
не-`static` членам. Статическая функция-член может быть использована вами для
получения доступа ко всем экземплярам структуры, вместо текущего экземпляра, или
когда функция-член должна использоваться вызывателями, которые не имеют
доступного экземпляра. Например, использовать `static` для шаблона
проектирования Singleton (разрешен только один экземпляр).

### Наследование

Обратите внимание, что структура не может наследовать от другой структуры.
Иерархия типов может быть собрана только через классы, которые мы рассмотрим в
одном из следующих разделов. Однако, с помощью `alias this` или `mixins` можно
легко достичь полиморфного наследования.

### Подробнее

- [Структуры в _Programming in D_](http://ddili.org/ders/d.en/struct.html)
- [Спецификация структур](https://dlang.org/spec/struct.html)

### Упражнение

Учитывая `struct Vector3` реализуйте следующие функции и сделайте, чтобы пример
приложения успешно выполнялся:

* `length()` - возвращает длину вектора
* `dot(Vector3)` - возвращает скалярное произведение двух векторов
* `toString()` - возвращает строковое представление вектора.
  Функция [`std.string.format`](https://dlang.org/phobos/std_format.html)
  возвращает строку, используя `printf`-подобный синтаксис:
  `format("MyInt = %d", myInt)`. Более подробно строки будут рассмотрены в одном
  из следующих разделов.

## {SourceCode:incomplete}

```d
struct Vector3 {
    double x;
    double y;
    double z;

    double length() const {
        import std.math: sqrt;
        return 0.0;
    }

    // rhs будет скопировано
    double dot(Vector3 rhs) const {
        return 0.0;
    }

    /**
    Возвращает: представление строки в
    специальном формате. Точность вывода
    ограничивается одной десятой!
    "x: 0.0 y: 0.0 z: 0.0"
    */
    string toString() const {
        import std.string: format;
        // Подсказка: обратитесь к документации
        // по std.format, чтобы посмотреть, как
        // можно влиять на вывод чисел с
        // плавающей запятой.
        return format("");
    }
}

void main() {
    auto vec1 = Vector3(10.0, 0.0, 0.0);
    Vector3 vec2;
    vec2.x = 0.0;
    vec2.y = 20.0;
    vec2.z = 0.0;

    // Если функция-член не имеет параметров,
    // вызывающие скобки () можно опустить
    assert(vec1.length == 10.0);
    assert(vec2.length == 20.0);

    // Проверка функциональности скалярного
    // произведения
    assert(vec1.dot(vec2) == 0.0);

    // Благодаря toString() теперь мы можем
    // просто вывести наши вектора через writeln
    import std.stdio: writeln, writefln;
    writeln("My vec1 = ", vec1);
    writefln("My vec2 = %s", vec2);

    // Проверка строкового представления
    assert(vec1.toString() ==
        "x: 10.0 y: 0.0 z: 0.0");
    assert(vec2.toString() ==
        "x: 0.0 y: 20.0 z: 0.0");
}
```

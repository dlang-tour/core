# Срезы

Срезы - это объекты типа `T[]`, заданные длялюбого типа `T`. Срезы обеспечивают
представление значений подмножества массива типа `T`, либо просто указывает на
весь массив. **Срезы и динамические массивы - одно и то же.**

Срез состоит из двух элементов - указателя на первый элемент и длину среза:

    T* ptr;
    size_t length; // беззнаковое 32/64 бита, в
                   // зависимости от архитектуры

Если был создан новый динамический массив, будет возвращён срез  на эту
свежевыделенную память:

    auto arr = new int[5];
    assert(arr.length == 5); // память,
                             // указываемая arr.ptr

Использование синтаксиса субсреза `[start .. end]`, который содержит все
элементы от `start` до элемента, находящегося _перед_ элементом `end`, создаётся
из существующего среза:

    auto newArr = arr[1 .. 4]; // индекс 4 НЕ входит
    assert(newArr.length == 3);
    newArr[0] = 10; // меняет newArr[0], он же arr[1]

Срезы создают новый вид на существующую память. Они *не* создают новую копию.
Если ни один срез больше не содержит ссылок на эту память, или на её субсрез,
память будет освобождена сборщиком мусора.

Используя срезы, можно писать очень эффективный код, например, для парсеров,
которые просто оперируют одним блоком памяти и просто берут срезы частей, с
которыми действительно нужно работать - нет необходимости в выделении новых
блоков памяти.

Как было видно в предыдущем разделе, выражение `[$]` является более короткой
записью `arr.length`. Следовательно, `arr[$]` указывает на следующий за
последним элемент и обращение к нему сгенерирует ошибку `RangeError` (если
проверка границ массива не была отключена).

### Подробнее

- [Introduction to Slices in D](http://dlang.org/d-array-article.html)
- [Slices in _Programming in D_](http://ddili.org/ders/d.en/slices.html)

## {SourceCode}

```d
import std.stdio;

/**
Рекурсивно вычисляет наименьшее значение в
срезе. Для каждого рекурсивного вызова берётся
субсрез, поэтому не нужно что-либо выделять.
*/
int minimum(int[] slice)
{
    assert(slice.length > 0);
    if (slice.length == 1)
        return slice[0];
    auto otherMin = minimum(slice[1 .. $]);
    return slice[0] < otherMin ?
        slice[0] : otherMin;
}

void main()
{
    int[] test = [ 3, 9, 11, 7, 2, 76, 90, 6 ];
    auto min = minimum(test);
    writefln("The minimum of %s is %d",
        test, min);
    assert(min == 2);
}
```
